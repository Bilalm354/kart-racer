{"id":"../node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js","dependencies":[{"name":"/Users/bilal/Projects/kart-racer/server/node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/bilal/Projects/kart-racer/server/package.json","includedInParent":true,"mtime":1610848218647},{"name":"/Users/bilal/Projects/kart-racer/server/node_modules/graphql-tools/package.json","includedInParent":true,"mtime":1602017675708},{"name":"graphql","loc":{"line":2,"column":24},"parent":"/Users/bilal/Projects/kart-racer/server/node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js","resolved":"/Users/bilal/Projects/kart-racer/server/node_modules/graphql/index.mjs"}],"generated":{"js":"Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\n// wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\nfunction addSchemaLevelResolveFunction(schema, fn) {\n    // TODO test that schema is a schema, fn is a function\n    var rootTypes = [\n        schema.getQueryType(),\n        schema.getMutationType(),\n        schema.getSubscriptionType(),\n    ].filter(function (x) { return !!x; });\n    rootTypes.forEach(function (type) {\n        // XXX this should run at most once per request to simulate a true root resolver\n        // for graphql-js this is an approximation that works with queries but not mutations\n        var rootResolveFn = runAtMostOncePerRequest(fn);\n        var fields = type.getFields();\n        Object.keys(fields).forEach(function (fieldName) {\n            // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n            // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n            if (type === schema.getSubscriptionType()) {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n            }\n            else {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n            }\n        });\n    });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n    return function (obj, args, ctx, info) {\n        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n            if (innerResolver) {\n                return innerResolver(root, args, ctx, info);\n            }\n            return graphql_1.defaultFieldResolver(root, args, ctx, info);\n        });\n    };\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n    var value;\n    var randomNumber = Math.random();\n    return function (root, args, ctx, info) {\n        if (!info.operation['__runAtMostOnce']) {\n            info.operation['__runAtMostOnce'] = {};\n        }\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\n            info.operation['__runAtMostOnce'][randomNumber] = true;\n            value = fn(root, args, ctx, info);\n        }\n        return value;\n    };\n}\nexports.default = addSchemaLevelResolveFunction;\n"},"sourceMaps":{"js":{"version":3,"file":"addSchemaLevelResolveFunction.js","sourceRoot":"","sources":["../../src/generate/addSchemaLevelResolveFunction.ts"],"names":[],"mappings":";AAAA,mCAIiB;AAEjB,wEAAwE;AACxE,8EAA8E;AAC9E,SAAS,6BAA6B,CACpC,MAAqB,EACrB,EAAkC;IAElC,sDAAsD;IACtD,IAAM,SAAS,GAAG;QAChB,MAAM,CAAC,YAAY,EAAE;QACrB,MAAM,CAAC,eAAe,EAAE;QACxB,MAAM,CAAC,mBAAmB,EAAE;KAC7B,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAC,CAAC;IACnB,SAAS,CAAC,OAAO,CAAC,UAAA,IAAI;QACpB,gFAAgF;QAChF,oFAAoF;QACpF,IAAM,aAAa,GAAG,uBAAuB,CAAC,EAAE,CAAC,CAAC;QAClD,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;QAChC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,UAAA,SAAS;YACnC,uFAAuF;YACvF,wFAAwF;YACxF,IAAI,IAAI,KAAK,MAAM,CAAC,mBAAmB,EAAE,EAAE;gBACzC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,GAAG,YAAY,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;aACzE;iBAAM;gBACL,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,GAAG,YAAY,CACtC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,EACzB,aAAa,CACd,CAAC;aACH;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,kFAAkF;AAClF,SAAS,YAAY,CACnB,aAAyD,EACzD,aAA6C;IAE7C,OAAO,UAAC,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI;QAC1B,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,UAAA,IAAI;YACnE,IAAI,aAAa,EAAE;gBACjB,OAAO,aAAa,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;aAC7C;YACD,OAAO,8BAAoB,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QACrD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAED,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,gDAAgD;AAChD,oDAAoD;AACpD,4DAA4D;AAC5D,SAAS,uBAAuB,CAC9B,EAAkC;IAElC,IAAI,KAAU,CAAC;IACf,IAAM,YAAY,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;IACnC,OAAO,UAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI;QAC3B,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,EAAE;YACtC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC;SACxC;QACD,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC,YAAY,CAAC,EAAE;YACpD,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;YACvD,KAAK,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;SACnC;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;AACJ,CAAC;AAED,kBAAe,6BAA6B,CAAC","sourcesContent":[null]}},"error":null,"hash":"ebd64514c4aed91a3b4c6bc0fabc1b87","cacheData":{"env":{}}}